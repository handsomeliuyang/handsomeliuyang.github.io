<!DOCTYPE html><html lang="zh-cn"><head><meta charset="utf-8"><title>Docker-Jenkins服务搭建 | LiuYang's blog</title><meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><meta name="format-detection" content="telephone=no"><meta name="author" content="[object Object]"><meta name="designer" content="minfive"><meta name="keywords" content="前端, 程序员, Android, Flutter, Kotlin, 全栈开发, node.js, javascript"><meta name="description" content="经验总结和日常学习的个人博客。"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><meta name="format-detection" content="telephone=yes"><meta name="mobile-web-app-capable" content="yes"><meta name="robots" content="all"><link rel="canonical" href="https://handsomeliuyang.github.io/2017/07/14/%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93/Docker-Jenkins%E6%9C%8D%E5%8A%A1%E6%90%AD%E5%BB%BA/index.html"><link rel="icon" type="image/png" href="/hexo-img/favicon.png" sizes="32x32"><link rel="stylesheet" href="/scss/base/index.css"><link rel="alternate" href="/atom.xml" title="刘阳" type="application/atom+xml"><link rel="stylesheet" href="/scss/views/page/post.css"><meta name="generator" content="Hexo 6.3.0"></head><body ontouchstart><div id="page-loading" class="page page-loading" style="background-image:url(/hexo-img/loading.gif)"></div><div id="page" class="page js-hidden"><header class="page__small-header page__header--small"><nav class="page__navbar"><div class="page__container navbar-container"><a class="page__logo" href="/" title="刘阳" alt="刘阳"><img src="/hexo-img/favicon.png" alt="刘阳"></a><nav class="page__nav"><ul class="nav__list clearfix"><li class="nav__item"><a href="/" alt="首页" title="首页">首页</a></li><li class="nav__item"><a href="/archives" alt="归档" title="归档">归档</a></li><li class="nav__item"><a href="/about" alt="关于" title="关于">关于</a></li></ul></nav><button class="page__menu-btn" type="button"><i class="iconfont icon-menu"></i></button></div></nav></header><main class="page__container page__main"><div class="page__content"><article class="page__post"><div class="post__cover"><img src="/hexo-img/default_cover.png" alt="Docker-Jenkins服务搭建"></div><header class="post__info"><h1 class="post__title">Docker-Jenkins服务搭建</h1><div class="post__mark"><div class="mark__block"><i class="mark__icon iconfont icon-write"></i><ul class="mark__list clearfix"><li class="mark__item"><a target="_blank" rel="noopener" href="https://github.com/handsomeliuyang">liuyang</a></li></ul></div><div class="mark__block"><i class="mark__icon iconfont icon-time"></i><ul class="mark__list clearfix"><li class="mark__item"><span>2017-07-14</span></li></ul></div><div class="mark__block"><i class="mark__icon iconfont icon-tab"></i><ul class="mark__list clearfix"><li class="mark__item"><a href="/tags/jenkins/">Jenkins</a></li><li class="mark__item"><a href="/tags/docker/">Docker</a></li></ul></div></div></header><div class="post__content"><h1 id="Docker介绍"><a href="#Docker介绍" class="headerlink" title="Docker介绍"></a>Docker介绍</h1><p>Docker 是一个开源的应用容器引擎，基于 Go 语言 并遵从Apache2.0协议开源。可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。<br>容器是完全使用沙箱机制，相互之间不会有任何接口（类似 iPhone 的 app）,更重要的是容器性能开销极低。</p><h2 id="Docker理解"><a href="#Docker理解" class="headerlink" title="Docker理解"></a>Docker理解</h2><p><img src="/docker%E7%90%86%E8%A7%A3.png"></p><ol><li>Dockerfile面向开发，Docker 镜像成为交付标准，Docker 容器则涉及部署与运维</li><li>Docker类似于一个虚拟机，实现资源和系统环境的隔离</li><li>Docker镜像类似于Ghost系统，为了方便快速使用，已经完成了服务的所有配置。</li><li>DockerFile是一个脚本，用于生成Docker镜像的脚本</li><li>Docker镜像不仅可以从DockerFile生成，也可以从Docker容器生成，但最好是通过DockerFile来生成，方便后期维护。</li><li>我们创建新的镜像都是从系统镜像开始创建的，如centos:7，centos：6</li></ol><h1 id="通过Docker部署Jenkins的好处"><a href="#通过Docker部署Jenkins的好处" class="headerlink" title="通过Docker部署Jenkins的好处"></a>通过Docker部署Jenkins的好处</h1><p>Docker解决现在的迁移服务(如Android的Jenkins)存在的问题：</p><ol><li>服务器的系统版本不一致，容易出现新问题，如缺少一些库，或软件版本过底<br>Docker：容器里的操作系统版本与主机的系统版本没有关系，不受主机的系统版本影响</li><li>多个服务部署在同一台机器上，关联的软件出现相互影响<br>Docker：每个容器之间相互不影响，完全透明，类似虚拟机</li><li>需要写服务部署文档，软件版本之间的关系，但新系统有可能不支持这些老版本的软件<br>Docker：DockerFile就是整个部署文档，安装的软件与主机的系统没有关系</li><li>服务卸载的成本很高，很容易出现卸载不完全的问题<br>Docker：只需要删除容器，其安装的软件都可以清除</li><li>服务升级很不方便，需要一台新机器或搭建虚拟机来实现<br>Docker：容器升级操作系统版本非常简单，成本非常低，修改From的关联版本就行</li><li>本地文件管理比较乱，容易相互影响<br>Docker：容器之间的文件相互不影响</li></ol><h1 id="Docker入门介绍"><a href="#Docker入门介绍" class="headerlink" title="Docker入门介绍"></a>Docker入门介绍</h1><h2 id="Docker安装"><a href="#Docker安装" class="headerlink" title="Docker安装"></a>Docker安装</h2><p>在centos上安装Docker的注意点：</p><ol><li>最低支持centos7.0系统才能安装docker</li><li>centos6.5以上也可以安装，但安装方法与centos7.0以上的安装方法不一样</li><li>具体教程可以网上查找</li></ol><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><h3 id="DockerFile生成Docker镜像"><a href="#DockerFile生成Docker镜像" class="headerlink" title="DockerFile生成Docker镜像"></a>DockerFile生成Docker镜像</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker build -t 镜像名称 DockerFile所在的目录</span><br><span class="line"></span><br><span class="line">// 例子</span><br><span class="line">docker build -t btown-jenkins .</span><br></pre></td></tr></table></figure><h3 id="从Docker镜像创建Docker容器"><a href="#从Docker镜像创建Docker容器" class="headerlink" title="从Docker镜像创建Docker容器"></a>从Docker镜像创建Docker容器</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker run [-d|-it] -p 主机端口:容器里的端口 -v 主机目录:容器里的目录 -v 主机目录:容器里的目录 镜像名称 bash</span><br><span class="line"></span><br><span class="line">// 例子</span><br><span class="line">docker run -it --name btown-jenkins -p 7000:8080 -v /data0/btown_jenkins_home/jobs:/var/lib/jenkins/jobs -v /data0/btown_jenkins_home/logs:/var/lib/jenkins/logs -v /data0/btown_jenkins_home/nodes:/var/lib/jenkins/nodes -v /data0/btown_jenkins_home/secrets:/var/lib/jenkins/secrets -v /data0/btown_jenkins_home/users:/var/lib/jenkins/users -v /data0/btown_jenkins_home/workspace:/var/lib/jenkins/workspace btown-jenkins bash</span><br></pre></td></tr></table></figure><ol><li>-d：此容器在后台运行</li><li>-it：当前控制台与容器交互</li><li>–name：创建的容器的名称</li><li>-p：端口映射，把主机的端口映射到容器里的端口</li><li>-v：目录映射，把容器里的目录映射到主机里的目录</li><li>bash：进入容器后的命令，bash表示直接进入shell状态</li></ol><h3 id="数据备份"><a href="#数据备份" class="headerlink" title="数据备份"></a>数据备份</h3><p>默认情况下，容器运行期间产生的文件，都处于沙箱当中，当容器删除后，也会自动删除，这会造成一些问题：</p><ol><li>服务生成的数据很不方便备份</li><li>容器挂了后，就无法恢复数据了</li><li>容器会变的非常的大</li><li>无法共享容器间的数据</li></ol><h4 id="Docker-容器文件系统"><a href="#Docker-容器文件系统" class="headerlink" title="Docker 容器文件系统"></a>Docker 容器文件系统</h4><p><img src="/Docker%E5%AE%B9%E5%99%A8%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F.png"></p><ol><li>Dockerfile 中的每一条命令，都在 Docker 镜像中以一个独立镜像层的形式存在</li><li>Docker 镜像是由 Dockerfile 构建而成，但并不是每一层 Docker 镜像中都含有相应的文件系统文件</li><li>Docker 容器的文件系统中不仅包含 Docker 镜像，还包含初始层（Init Layer）与可读写层（Read-Write Layer）。<ol><li>初始化层（Init Layer）：初始层中大多是初始化容器环境时，与容器相关的环境信息，如容器主机名，主机 host 信息以及域名服务文件等。</li><li>可读写层（Read-Write Layer）：这一层的作用非常大，Docker 的镜像层以及顶上的两层加起来，Docker 容器内的进程只对可读写层拥有写权限，其他层对进程而言都是只读的（Read-Only）</li></ol></li><li>Docker 容器有能力在可读写层看到VOLUME文件等内容，但那都仅仅是挂载点，真实内容位于宿主机上</li></ol><h4 id="Volume-命令"><a href="#Volume-命令" class="headerlink" title="Volume 命令"></a>Volume 命令</h4><p>为了能够保存（持久化）数据以及共享容器间的数据，Docker提出了Volume的概念。简单来说，Volume就是目录或者文件，它可以绕过默认的联合文件系统，而以正常的文件或者目录的形式存在于宿主机上。</p><p>有两种方式初始化Volume：</p><ol><li>不指定主机上的目录<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="keyword">run</span><span class="language-bash"> -it --name btown-jenkins -v /data btown-jenkins bash</span></span><br></pre></td></tr></table></figure>此命令会将&#x2F;data挂载到容器中，并绕过联合文件系统，我们可以在主机上直接操作该目录，通过docker inspect命令找到Volume在主机上的存储位置：<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker inspect -f &#123;&#123;.Volumes&#125;&#125; btown-jenkins</span><br></pre></td></tr></table></figure>类似的输出为：<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">map[/data:/var/lib/docker/vfs/dir/cde167197ccc3e138a14f1a4f...b32cec92e79059437a9] </span><br></pre></td></tr></table></figure></li><li>指定主机上的目录：<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="keyword">run</span><span class="language-bash"> -it --name btown-jenkins -v /home/data:/data btown-jenkins bash</span></span><br></pre></td></tr></table></figure>命令将挂载主机的&#x2F;home&#x2F;data目录到容器内的&#x2F;data目录上</li></ol><p>通过Volume挂载关键数据目录后，就可以解决上面出现的问题了</p><h3 id="其他常用命令"><a href="#其他常用命令" class="headerlink" title="其他常用命令"></a>其他常用命令</h3><ol><li>查看所有镜像：docker images</li><li>删除镜像：docker rmi xxx</li><li>查看所有容器：docker ps -a</li><li>删除容器：docker rm xxx</li><li>退出容器：exit，CTRL+D</li><li>重新连接容器：<ol><li>docker attach xxx</li><li>docker exec -it xxx bash</li><li>差别：使用docker exec连接容器后，现执行exit退出容器，容器不会停止</li></ol></li><li>启动|停止容器：docker start|stop</li></ol><h2 id="DockerFile脚本语言"><a href="#DockerFile脚本语言" class="headerlink" title="DockerFile脚本语言"></a>DockerFile脚本语言</h2><p>Dockerfile 是一个类似 Makefile 的工具，主要用来自动化构建镜像。</p><p>先看一个例子：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 系统版本 由于需要glibc-2.14版本以上，所以要使用centos:7</span></span><br><span class="line"><span class="keyword">FROM</span> centos:<span class="number">7.3</span>.<span class="number">1611</span></span><br><span class="line"><span class="comment"># 作者信息</span></span><br><span class="line"><span class="keyword">MAINTAINER</span> liuyang@<span class="number">58</span>ganji.com</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装基础库</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> yum -y update</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> yum -y install wget</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装 Oracle Java 7 JDK，安装成功的目录：/usr/java/jdk1.7</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">mkdir</span> -p /data0/soft</span></span><br><span class="line"><span class="keyword">ADD</span><span class="language-bash"> ./jdk-7u80-linux-x64.rpm /data0/soft/jdk-7u80-linux-x64.rpm</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> rpm -ivh /data0/soft/jdk-7u80-linux-x64.rpm</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置jdk的环境变量</span></span><br><span class="line"><span class="keyword">ENV</span> JAVA_HOME /usr/java/jdk1.<span class="number">7.0</span>_80</span><br><span class="line"><span class="keyword">ENV</span> PATH $PATH:$JAVA_HOME/jre/bin:$JAVA_HOME/bin</span><br><span class="line"></span><br><span class="line"><span class="comment"># 复制ssh key</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> ./ssh.tar /data0/soft/ssh.tar</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">cd</span> /data0/soft &amp;&amp; tar xvf ssh.tar</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">cp</span> -r -f /data0/soft/.ssh /var/lib/jenkins/</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">chmod</span> -R 777 /var/lib/jenkins/.ssh</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">8080</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> service jenkins start</span></span><br></pre></td></tr></table></figure><h3 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h3><p>Dockerfile 中所有的命令都是以下格式：<font color="#ff0000">INSTRUCTION argument</font></p><p>指令(INSTRUCTION)不分大小写，但是推荐大写。</p><h3 id="FROM-命令"><a href="#FROM-命令" class="headerlink" title="FROM 命令"></a>FROM 命令</h3><p><font color="#ff0000">FROM &lt;image name&gt;</font>，例如 <font color="#ff0000">FROM ubuntu</font></p><p>所有的 Dockerfile 都用该以 FROM 开头，FROM 命令指明 Dockerfile 所创建的镜像文件以什么镜像为基础，FROM 以后的所有指令都会在 FROM 的基础上进行创建镜像；可以在同一个 Dockerfile 中多次使用 FROM 命令用于创建多个镜像。</p><h3 id="MAINTAINER-命令"><a href="#MAINTAINER-命令" class="headerlink" title="MAINTAINER 命令"></a>MAINTAINER 命令</h3><p><font color="#ff0000">MAINTAINER &lt;author name&gt;</font> 用于指定镜像创建者和联系方式。</p><h3 id="RUN-命令"><a href="#RUN-命令" class="headerlink" title="RUN 命令"></a>RUN 命令</h3><p><font color="#ff0000">RUN &lt;command&gt;</font> 用于容器内部执行命令。每个 RUN 命令相当于在原有的镜像基础上添加了一个改动层，原有的镜像不会有变化。</p><h3 id="ADD-命令"><a href="#ADD-命令" class="headerlink" title="ADD 命令"></a>ADD 命令</h3><p><font color="#ff0000">ADD &lt;src&gt; &lt;dst&gt;</font> 用于从将 &lt;src&gt; 文件复制到 &lt;dst&gt;<br>文件：&lt;src&gt; 是相对被构建的源目录的相对路径，可以是文件或目录的路径，也可以是一个远程的文件 url，&lt;dst&gt; 是容器中的绝对路径。</p><p><em><strong>注意</strong></em>：如果源文件是压缩文件（如.tar,.zip等等），会自动解压，如果不想自动解压，可以使用copy命令</p><h3 id="COPY指令"><a href="#COPY指令" class="headerlink" title="COPY指令"></a>COPY指令</h3><p>COPY指令和ADD指令功能和使用方式类似。只是COPY指令不会做自动解压工作。</p><h3 id="ENV-命令"><a href="#ENV-命令" class="headerlink" title="ENV 命令"></a>ENV 命令</h3><p>设置环境变量，参考 export 的用法咧：<br>ENV LC_ALL en_US.UTF-8</p><h3 id="EXPOSE-命令"><a href="#EXPOSE-命令" class="headerlink" title="EXPOSE 命令"></a>EXPOSE 命令</h3><p><font color="#ff0000">EXPOSE &lt;port&gt; [&lt;port&gt;…]</font> 命令用来指定对外开放的端口。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXPOSE</span> <span class="number">80</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">8080</span></span><br><span class="line"><span class="comment"># 不推荐这样写，会固定死映射端口，最好通过创建容器时来指定</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">8000</span>:<span class="number">8080</span>  </span><br></pre></td></tr></table></figure><p>注意：除EXPOSE 8000:8080是提前指定了映射端口外，其他的相当于一个声明而已，具体端口映射还是在创建容器时指定的。</p><h3 id="ENTRYPOINT-命令"><a href="#ENTRYPOINT-命令" class="headerlink" title="ENTRYPOINT 命令"></a>ENTRYPOINT 命令</h3><p><font color="#ff0000">ENTRYPOINT command param1 param2</font> 用来指定启动容器时，执行的命令</p><h1 id="生成DockerFile的流程"><a href="#生成DockerFile的流程" class="headerlink" title="生成DockerFile的流程"></a>生成DockerFile的流程</h1><p>由于每个重新执行一次DockerFile文件的时间很长，所以写DockerFile的最佳方案：</p><ol><li>创建一个最初的容器，再执行成功一个命令后，就添加到DockerFile文件里，等全部OK后，DockerFile也就创建完了</li><li>再整体执行DockerFile文件，查看创建镜像是否成功</li></ol><h1 id="Docker的容器的性能"><a href="#Docker的容器的性能" class="headerlink" title="Docker的容器的性能"></a>Docker的容器的性能</h1><p>具体内容请查看：<a target="_blank" rel="noopener" href="http://blog.csdn.net/cbl709/article/details/43955687">docker与虚拟机性能比较</a></p><p><img src="/docker%E4%B8%8E%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%AF%94%E8%BE%83.png"></p><ol><li>docker比虚拟机的优势：<ol><li>docker有着比虚拟机更少的抽象层</li><li>docker利用的是宿主机的内核，而不需要Guest OS</li><li>docker计算效率与主机一样，没有损耗，但虚拟机的计算能力损耗在50%左右<br><img src="/%E8%AE%A1%E7%AE%97%E6%95%88%E7%8E%87.png"></li><li>docker与虚拟机内存访问效率要高<br><img src="/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98.png"></li><li>docker与虚拟机启动时间及资源耗费要高</li></ol></li><li>docker的劣势：<ol><li>资源隔离方面不如虚拟机，docker是利用cgroup实现资源限制的，只能限制资源消耗的最大值，而不能隔绝其他程序占用自己的资源</li><li>安全性问题。docker目前并不能分辨具体执行指令的用户，只要一个用户拥有执行docker的权限，那么他就可以对docker的容器进行所有操作，不管该容器是否是由该用户创建。比如A和B都拥有执行docker的权限，由于docker的server端并不会具体判断docker cline是由哪个用户发起的，A可以删除B创建的容器，存在一定的安全风险。</li><li>docker目前还在版本的快速更新中，细节功能调整比较大。一些核心模块依赖于高版本内核，存在版本兼容问题</li></ol></li></ol><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a target="_blank" rel="noopener" href="http://www.runoob.com/docker/docker-tutorial.html">Docker 教程</a></li><li><a target="_blank" rel="noopener" href="http://guide.daocloud.io/dcs/docker-9153976.html">一图看尽 docker 容器文件系统</a></li><li><a target="_blank" rel="noopener" href="http://blog.csdn.net/cbl709/article/details/43955687">docker与虚拟机性能比较</a></li></ol><div class="post-announce">感谢您的阅读，本文由 <a href="https://handsomeliuyang.github.io">刘阳</a> 版权所有。如若转载，请注明出处：刘阳（<a href="https://handsomeliuyang.github.io/2017/07/14/%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93/Docker-Jenkins%E6%9C%8D%E5%8A%A1%E6%90%AD%E5%BB%BA/">https://handsomeliuyang.github.io/2017/07/14/%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93/Docker-Jenkins%E6%9C%8D%E5%8A%A1%E6%90%AD%E5%BB%BA/</a>）</div><div class="post__prevs"><div class="post__prev"><a href="/2017/03/14/%E6%97%A5%E5%B8%B8%E5%AD%A6%E4%B9%A0/Axure%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%9E%8B%E5%9B%BE/" title="如何设计高保真原型图"><i class="iconfont icon-prev"></i>如何设计高保真原型图</a></div><div class="post__prev post__prev--right"><a href="/2017/08/18/%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93/%E5%BC%82%E6%88%96%E6%80%BB%E7%BB%93/" title="异或总结">异或总结<i class="iconfont icon-next"></i></a></div></div></div></article></div><aside class="page__sidebar"><form id="page-search-from" class="page__search-from" action="/search/"><label class="search-form__item"><input class="input" type="text" name="search" placeholder="Search..."> <i class="iconfont icon-search"></i></label></form><div class="sidebar__block"><h3 class="block__title">简介</h3><p class="block__text">经验总结和日常学习的个人博客。</p></div><div class="sidebar__block"><h3 class="block__title">文章分类</h3><ul class="block-list"><li class="block-list-item"><a class="block-list-link" href="/categories/%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93/">经验总结</a><span class="block-list-count">32</span></li><li class="block-list-item"><a class="block-list-link" href="/categories/%E6%97%A5%E5%B8%B8%E5%AD%A6%E4%B9%A0/">日常学习</a><span class="block-list-count">29</span></li><li class="block-list-item"><a class="block-list-link" href="/categories/%E6%96%87%E7%AB%A0%E8%BD%AC%E5%8F%91/">文章转发</a><span class="block-list-count">1</span></li></ul></div><div class="sidebar__block"><h3 class="block__title">最新文章</h3><ul class="block-list latest-post-list"><li class="latest-post-item"><a href="/2023/10/08/%E6%97%A5%E5%B8%B8%E5%AD%A6%E4%B9%A0/Android%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9AAndroid%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B%E7%AE%A1%E7%90%86/" title="Android内核学习笔记：Android进程\线程管理"><div class="item__cover"><img src="/hexo-img/default_cover.png" alt="Android内核学习笔记：Android进程\线程管理"></div><div class="item__info"><h3 class="item__title">Android内核学习笔记：Android进程\线程管理</h3><span class="item__text">2023-10-08</span></div></a></li><li class="latest-post-item"><a href="/2023/08/08/%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93/ASM%E5%AD%A6%E4%B9%A0%E5%BF%83%E5%BE%97/" title="ASM 学习心得"><div class="item__cover"><img src="/hexo-img/default_cover.png" alt="ASM 学习心得"></div><div class="item__info"><h3 class="item__title">ASM 学习心得</h3><span class="item__text">2023-08-08</span></div></a></li><li class="latest-post-item"><a href="/2023/02/22/%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93/App%E7%9A%84Repo%E5%A4%9A%E4%BB%93%E5%BA%93%E7%AE%A1%E7%90%86/" title="App的Repo多仓库管理"><div class="item__cover"><img src="/hexo-img/default_cover.png" alt="App的Repo多仓库管理"></div><div class="item__info"><h3 class="item__title">App的Repo多仓库管理</h3><span class="item__text">2023-02-22</span></div></a></li><li class="latest-post-item"><a href="/2022/11/02/%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93/%E4%BB%8E%E5%BC%80%E5%8F%91%E8%80%85%E8%A7%92%E5%BA%A6%E6%80%9D%E8%80%83%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E7%9A%84%E4%BB%B7%E5%80%BC/" title="从开发者角度思考单元测试的价值"><div class="item__cover"><img src="/hexo-img/default_cover.png" alt="从开发者角度思考单元测试的价值"></div><div class="item__info"><h3 class="item__title">从开发者角度思考单元测试的价值</h3><span class="item__text">2022-11-02</span></div></a></li></ul></div><div class="sidebar__block"><h3 class="block__title">文章标签</h3><ul class="block-list tag-list clearfix"><li class="tag-item"><a class="tag-link" href="/tags/AOP/">AOP</a></li><li class="tag-item"><a class="tag-link" href="/tags/ASM/">ASM</a></li><li class="tag-item"><a class="tag-link" href="/tags/Android/">Android</a></li><li class="tag-item"><a class="tag-link" href="/tags/Android%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">Android内核学习笔记</a></li><li class="tag-item"><a class="tag-link" href="/tags/Dart/">Dart</a></li><li class="tag-item"><a class="tag-link" href="/tags/Flutter/">Flutter</a></li><li class="tag-item"><a class="tag-link" href="/tags/Gradle/">Gradle</a></li><li class="tag-item"><a class="tag-link" href="/tags/Kotlin/">Kotlin</a></li><li class="tag-item"><a class="tag-link" href="/tags/NAS/">NAS</a></li><li class="tag-item"><a class="tag-link" href="/tags/OpenGL/">OpenGL</a></li><li class="tag-item"><a class="tag-link" href="/tags/React/">React</a></li><li class="tag-item"><a class="tag-link" href="/tags/ReactNative/">ReactNative</a></li><li class="tag-item"><a class="tag-link" href="/tags/Robot/">Robot</a></li><li class="tag-item"><a class="tag-link" href="/tags/axure/">axure</a></li><li class="tag-item"><a class="tag-link" href="/tags/docker/">docker</a></li><li class="tag-item"><a class="tag-link" href="/tags/electron/">electron</a></li><li class="tag-item"><a class="tag-link" href="/tags/hexo/">hexo</a></li><li class="tag-item"><a class="tag-link" href="/tags/jenkins/">jenkins</a></li><li class="tag-item"><a class="tag-link" href="/tags/leetcode/">leetcode</a></li><li class="tag-item"><a class="tag-link" href="/tags/nodejs/">nodejs</a></li><li class="tag-item"><a class="tag-link" href="/tags/python/">python</a></li><li class="tag-item"><a class="tag-link" href="/tags/%E5%89%8D%E7%AB%AF/">前端</a></li><li class="tag-item"><a class="tag-link" href="/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/">小程序</a></li><li class="tag-item"><a class="tag-link" href="/tags/%E5%BC%80%E5%8F%91%E6%A8%A1%E5%BC%8F/">开发模式</a></li><li class="tag-item"><a class="tag-link" href="/tags/%E6%94%B6%E8%97%8F/">收藏</a></li><li class="tag-item"><a class="tag-link" href="/tags/%E7%AE%97%E6%B3%95/">算法</a></li><li class="tag-item"><a class="tag-link" href="/tags/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/">自动化测试</a></li><li class="tag-item"><a class="tag-link" href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a></li></ul></div></aside></main><footer class="page__footer"><section class="footer__top"><div class="footer_wrap"><div class="footer_background"><div class="clouds"></div><div class="background"></div><div class="foreground"></div></div><div class="footer_content"><div><span class="face">ღゝ◡╹)ノ♡</span></div><div>"【人生若只如初见，何事秋风悲画扇】"</div></div></div></section><section class="footer__bottom"><div class="page__container footer__container"><p class="footer__copyright">© <a href="https://github.com/handsomeliuyang" target="_blank">刘阳</a> <a href="mailto:40610243@qq.com">40610243@qq.com</a></p><ul class="footer__social-network clearfix"></ul></div></section></footer><div id="back-top" class="back-top back-top--hidden js-hidden"><i class="iconfont icon-top"></i></div></div><script type="text/javascript" src="/js/common/utils.js"></script><script type="text/javascript" src="/js/common/pack.js"></script><script type="text/javascript" src="/js/common/animation.js"></script><script type="text/javascript" src="/js/layout/loading.js"></script><script type="text/javascript" src="/js/layout/header.js"></script><script type="text/javascript" src="/js/layout/back-top.js"></script><script type="text/javascript" src="/js/layout/post.js"></script><script src="/js/page/post.js"></script></body></html>